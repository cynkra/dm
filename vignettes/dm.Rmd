---
title: "Getting Started"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
fansi::set_knit_hooks(knitr::knit_hooks)
options(crayon.enabled = TRUE, width = 75, cli.width = 75)

knit_print.grViz <- function(x, ...) {
  x %>% 
    DiagrammeRsvg::export_svg() %>% 
    c("`````{=html}\n", ., "\n`````\n") %>% 
    knitr::asis_output()
}
```

The goal of the package {dm} and its `dm` class is to facilitate work with multiple related tables.
An object of the `dm` class contains all relevant information about the tables in a data model:

1. the place where the tables live (i.e., the `src`: a database (DB) or locally in your R session)
1. the metadata from the data model: the tables, columns and key constraints
1. the data in the tables

This package augments [{dplyr}](https://dplyr.tidyverse.org/)/[{dbplyr}](https://dbplyr.tidyverse.org/) workflows:

- multiple related tables are kept in a single compound object
- joins across multiple tables are available by specifying the tables involved, no need to memorize column names or relationships

In addition, a battery of utilities is provided that helps with creating a tidy data model.

This package follows several of the "tidyverse" rules:

- `dm` objects are immutable (your data will never be overwritten in place)
- many functions used on `dm` objects are pipeable (i.e., return new `dm` objects)
- tidy evaluation is used (unquoted function parameters are supported)

The {dm} package builds heavily upon the [{datamodelr} package](https://github.com/bergant/datamodelr), and upon the [tidyverse](https://www.tidyverse.org/).
We're looking forward to a great collaboration!

We will now demonstrate some of the features of {dm}:

1. [Creation of `dm` objects](#create)
1. [Setting keys and drawing](#keys)
1. [Filtering](#filter)
1. [Copying and discovery](#copy)

Let's first have a brief look at how to create a `dm`-class object.

```{r message=FALSE}
library(dm)
library(tidyverse)
```


## Creating `dm` objects: {#create}

The [{nycflights13}](https://github.com/hadley/nycflights13) package offers a nice example of interconnected tables.
The most straightforward way of squeezing those tables into a `dm` object is:

```{r message=FALSE}
flights_dm <- dm_from_src(src_df(pkg = "nycflights13"))
flights_dm
```

This fairly verbose output shows the three components of a `dm` object: the table source, the metadata, and row counts.
These components can be accessed with `cdm_get_src()` and `cdm_get_tables()`.

```{r}
cdm_get_src(flights_dm)
cdm_get_filter(flights_dm)
cdm_get_all_pks(flights_dm)
cdm_get_all_fks(flights_dm)
```


## Keys and visualization {#keys}

As you can see in the "Data model" part of the output above, no keys have been set so far.
We will use `cdm_add_pk()` and `cdm_add_fk()` to add primary keys (pk) and foreign keys (fk):

```{r}
flights_dm_with_one_key <- 
  flights_dm %>% 
  cdm_add_pk(airlines, carrier) %>% 
  cdm_add_fk(flights, carrier, airlines)
```

After you set the keys and establish relations, you can create a graphical representation of your data model with `cdm_draw()`:

```{r}
flights_dm_with_one_key %>% 
  cdm_draw()
```

The `cdm_nycflights13()` function provides a shortcut: the `dm` object returned by this function contains all tables, defines all primary and foreign keys, and even assigns colors to the different types of tables.
We will be using the `dm` object created by this function from now on.

```{r}
flights_dm_with_keys <- cdm_nycflights13(cycle = TRUE)
flights_dm_with_keys %>% 
  cdm_draw()
```


## Filtering a table of a `dm` object {#filter}

The idea of a filter on a `dm` object:

1. You can filter one or more of `dm`'s tables, just like with normal `dplyr::filter()` calls
1. Filtering conditions are stored in the `dm` object but not immediately executed
1. Once you access a table, all relevant filtering conditions are applied to the respective tables, and the necessary joins are performed along the fk relations.
This results in a table that contains only rows related to the filtering operations

Currently, this only works if the graph induced by the fk relations is cycle free, the default for `cdm_nycflights13()`:

```{r}
flights_dm_acyclic <- cdm_nycflights13()
flights_dm_acyclic %>% 
  cdm_draw()
```

Let's set two filters:

```{r}
us_flights_from_jfk_prepared <- 
  flights_dm_acyclic %>%
  cdm_filter(airports, name == "John F Kennedy Intl") %>% 
  cdm_filter(airlines, name == "US Airways Inc.")
us_flights_from_jfk_prepared
```

With `cdm_apply_filters()`, you can apply all filters and therefore update all tables in the `dm`, so that they contain only the rows that are relevant to the filters. 
The effect of the filters can be seen when counting the rows:

```{r}
us_flights_from_jfk <- cdm_apply_filters(us_flights_from_jfk_prepared)
us_flights_from_jfk %>% 
  cdm_get_tables() %>% 
  map_int(nrow)
```

Alternatively, you can just pull out one of the tables from `dm` to answer the question which planes were used to service the US Airways flights that departed from JFK airport:

```{r}
tbl(us_flights_from_jfk, "planes")
```

Each of the planes in the result set above was a part of at least one US Airways flight departing from JFK.
Do they have any common characteristics?

```{r}
tbl(us_flights_from_jfk, "planes") %>% 
  count(model)
```

For comparison, let's look at the equivalent manual query in {dplyr} syntax:

```{r eval=FALSE}
flights %>% 
  left_join(airports, by = c("origin" = "faa")) %>% 
  filter(name == "John F Kennedy Intl") %>%
  left_join(airlines, by = "carrier") %>% 
  filter(name.y == "US Airways Inc.") %>%
  semi_join(planes, ., by = "tailnum") %>% 
  count(model)
```

The {dm} code is leaner because the fk information is encoded in the object.

### Joining two tables {#join}

The `cdm_join_to_tbl()` function joins two immediately related tables in a data model.
The definition of the primary and foreign key constraints is used to define the relationship.

```{r}
flights_dm_with_keys %>%
  cdm_join_to_tbl(airlines, flights, join = left_join)
```

The same operation using {dplyr} syntax looks like this:

```{r eval=FALSE}
library(nycflights13)
airlines %>% 
  left_join(flights, by = "carrier")
```

Omitting the `by` argument leads to a warning.

## Copy a `dm` object to a DB or learn from it {#copy}

`dm` objects can be transferred from one `src` to another.
The relevant verb is `cdm_copy_to()`, which will copy both data and key constraints.

```{r}
src_sqlite <- src_sqlite(":memory:", create = TRUE)
src_sqlite
flights_dm_with_keys_remote <- cdm_copy_to(src_sqlite, flights_dm_with_keys)
```

As a result, the tables are transferred to the target data source, and all keys will be contained in the returned data model.

```{r}
src_sqlite
flights_dm_with_keys_remote
```

In the opposite direction, `dm` objects can also be "learned" from a DB, including the key constraints, by utilizing the DB's meta-information tables.
Unfortunately, this currently only works for MSSQL and Postgres, so we cannot show the results here just yet:

```{r eval=FALSE}
flights_dm_from_remote <- cdm_learn_from_db(src_sqlite)
```

## Further reading

- Learn other ways of creating `dm` objects and basic operations on them, like handling key constraints in the ["Class 'dm' and basic operations"](https://krlmlr.github.io/dm/articles/dm-class-and-basic-operations.html) article
- All about the possibilities of graphic representations of `dm` objects: the ["Visualizing 'dm' objects"](https://krlmlr.github.io/dm/articles/dm-visualization.html) article
- Constraints, cardinalities, and normalization: the ["Low level operations"](https://krlmlr.github.io/dm/articles/dm-low-level.html) article
