---
title: "Manipulating individual tables"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Technical: Manipulating individual tables}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

``````{r setup, include = FALSE}
source("setup/setup.R")
``````

This vignette deals with situations where you want to transform tables of your `dm` and then update an existing table or add a new table to the `dm`.
There are two straightforward approaches:

1. individually subsetting the tables relevant to the calculation, perform the necessary transformations, add the result to the `dm` (or replace an existing table), and establish the key relations.
1. do all this within the `dm` object by zooming to a table and manipulating it while maintaining the key relations whenever possible.

We will explore the first approach here. For the second approach, see `vignette("tech-dm-zoom")`.

## Enabling {dplyr}-workflow within a `dm`

Subsetting a table of a `dm` object produces an object of class `dm_keyed_tbl`.

{dm} provides methods for many of the {dplyr}-verbs for a `dm_keyed_tbl` which behave the way you are used to, affecting only the table and leaving the rest of the `dm` untouched.

When you are finished with transforming the table, there are three options to proceed:

1. use `dm()` if you want to replace the original tables with the new table
1. use `new_dm()`/`dm()` if you want to create a brand new `dm` object 

When employing these options, the resulting tables in the `dm` will have all the primary and foreign keys available that could be tracked from the original table.

## Examples

So much for the theory, but how does it look and feel?
To explore this, we once more make use of our trusted {nycflights13} data.

### Use case 1: Add a new column to an existing table

Imagine you want to have a column in `flights`, specifying if a flight left before noon or after.
Just like with {dplyr}, we can tackle this with `mutate()`.
Let us do this step by step:

```{r zoom}
library(dm)
library(dplyr)

flights_dm <- dm_nycflights13()
flights_dm

flights_tbl <- flights_dm$flights

# The print output for a `dm_keyed_tbl` looks very much like that from a normal
# `tibble`, with additional details about keys.
flights_tbl

flights_tbl_mutate <-
  flights_tbl %>%
  mutate(am_pm_dep = if_else(dep_time < 1200, "am", "pm")) %>%
  # in order to see our changes in the output we use `select()` for reordering
  # the columns
  select(year:dep_time, am_pm_dep, everything())

flights_tbl_mutate
```

To update the original `dm` with a new `flights` table we use `dm()`:

```{r zoom2, error=TRUE}
updated_flights_dm <- dm(
  flights = flights_tbl_mutate,
  flights_dm[c("airlines", "airports", "planes", "weather")]
)

# The only difference in the `dm` print output is the increased number of
# columns
updated_flights_dm

# The schematic view of the data model remains unchanged
dm_draw(updated_flights_dm)
```

### Use case 2: Creation of a surrogate key

The same course of action could, for example, be employed to create a surrogate key for a table.
We can do this for the `weather` table.

```{r, error=TRUE}
library(tidyr)

weather_tbl <- flights_dm$weather
weather_tbl

# Maybe there is some hidden candidate for a primary key that we overlooked
enum_pk_candidates(weather_tbl)

# Seems we have to construct a column with unique values
# This can be done by combining column `origin` with `time_hour`, if the latter
# is converted to a single time zone first; all within the `dm`:
weather_tbl_mutate <-
  weather_tbl %>%
  # first convert all times to the same time zone:
  mutate(time_hour_fmt = format(time_hour, tz = "UTC")) %>%
  # paste together as character the airport code and the time
  unite("origin_slot_id", origin, time_hour_fmt) %>%
  select(origin_slot_id, everything())

# check if we the result is as expected:
enum_pk_candidates(weather_tbl_mutate) %>% filter(candidate)

flights_upd_weather_dm <-
  dm(
    weather = weather_tbl_mutate,
    flights_dm[c("airlines", "airports", "planes", "flights")]
  ) %>%
  dm_add_pk(weather, origin_slot_id)

flights_upd_weather_dm

# creating the coveted FK relation between `flights` and `weather`
extended_flights_tbl <-
  flights_upd_weather_dm$flights %>%
  mutate(time_hour_fmt = format(time_hour, tz = "UTC")) %>%
  # need to keep `origin` as FK to airports, so `remove = FALSE`
  unite("origin_slot_id", origin, time_hour_fmt, remove = FALSE)

extended_flights_dm <- dm(
  flights = extended_flights_tbl,
  flights_dm[c("airlines", "airports", "planes", "weather")]
) %>%
  dm_add_fk(flights, origin_slot_id, weather)

extended_flights_dm %>% dm_draw()
```

### Use case 3: Disentangle `dm`

If you look at the `dm` created by `dm_nycflights13(cycle = TRUE)`, you see that two columns of `flights` relate to one and the same table, `airports`.
One column stands for the departure airport and the other for the arrival airport.

```{r}
dm_draw(dm_nycflights13(cycle = TRUE))
```

In such cases, it can be beneficial to "disentangle" the `dm` by duplicating the referred table.
One way to do this in the {dm}-framework is as follows:

```{r, error=TRUE}
flights_cycle_dm <- dm_nycflights13(cycle = TRUE)

disentangled_flights_dm <-
  dm(
    destination = flights_cycle_dm$airports,
    origin = flights_cycle_dm$airports,
    flights_dm[c("flights", "airlines", "planes", "weather")]
  ) %>%
  # Key relations are also duplicated, so the wrong ones need to be removed
  dm_rm_fk(flights, dest, origin) %>%
  dm_rm_fk(flights, origin, destination)

dm_draw(disentangled_flights_dm)
```

In a future update, we will provide a more convenient way to "disentangle" `dm` objects, so that the individual steps will be done automatically.

### Use case 4: Add summary table to `dm`

Here is an example for adding a summary of a table as a new table to a `dm` (FK-relations are taken care of automatically):

```{r, error=TRUE}
dm_with_summary <-
  flights_dm$flights %>%
  count(origin, carrier) 

flights_dm <- dm(
  dep_carrier_count = dm_with_summary,
  flights_dm[c("airlines", "airports", "flights", "planes", "weather")]
)

dm_draw(flights_dm)
```

### Use case 5: Joining tables

If you would like to join some or all of the columns of one table to another, you can make use of one of the `join`-methods for a `dm_keyed_tbl`.
In addition to the usual arguments for the {dplyr}-joins, by supplying the `select` argument you can specify which columns of the RHS-table you want to be included in the join.
For the syntax, please see the example below.
The LHS-table of a join is always the subsetted table.

```{r, error=TRUE}
joined_flights_tbl <-
  flights_dm$flights %>%
  # let's first reduce the number of columns of flights
  select(-dep_delay:-arr_delay, -air_time:-time_hour) %>%
  # in the {dm}-method for the joins you can specify which columns you want to
  # add to the subsetted table
  left_join(flights_dm$planes, select = c(tailnum, plane_type = type)) 

joined_flights_dm <- dm(
  flights_plane_type = joined_flights_tbl,
  flights_dm[c("airlines", "airports", "flights", "planes", "weather")]
)

# this is how the table looks now
joined_flights_dm$flights_plane_type

# also here, the FK-relations are transferred to the new table
dm_draw(joined_flights_dm)
```

