---
title: "Updating dm objects"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Updating dm objects}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
fansi::set_knit_hooks(knitr::knit_hooks)
options(crayon.enabled = TRUE, width = 75, cli.width = 75)

knit_print.grViz <- function(x, ...) {
  x %>%
    DiagrammeRsvg::export_svg() %>%
    c("`````{=html}\n", ., "\n`````\n") %>%
    knitr::asis_output()
}
library(nycflights13)
library(tidyverse)
library(dm)
```

This draft describes update operations on dm objects.

Operations on a dm object are generally transient or ephemeral.
Resulting dm or table objects must be stored in a new object otherwise they are lost.


## Design

- records tables from a source dm are appended/updated/upserted/removed/replaced/... from the target dm
- both dm must be compatible
    - same source
    - source has no extra tables and columns
    - PK columns must be present in source
- dry run supported: use transient operations instead of materialization
    - check integrity constraints are still valid after running
    - compare before-after state
- transactions out of scope, caller can use `DBI::withTransaction()`

## Challenges

- determine table name for remote tables
    - `dbplyr::remote_name()`
- make this work for both local and remote tables and for extensions
- some operations need top-down, others need bottom-up
    - fixed set of operations, each op knows its "direction"
- pass key columns to `tbl_xxx()` operations
    - for now with a separate `keys` argument (TBD), later perhaps using {keyholder} or a similar data structure that combines tables and keys

## Logic of operation

- check compatibility
- persist tables one by one, topologically sorted
- put back into dm if necessary


## API draft

```{r}
dm_insert <- function(target_dm, dm, ..., dry_run = FALSE) {
  check_dots_empty()

  dm_persist(target_dm, dm, operation = tbl_insert, top_down = TRUE, dry_run = dry_run)
}

dm_update <- function(target_dm, dm, ..., dry_run = FALSE) {
  check_dots_empty()

  dm_persist(target_dm, dm, operation = tbl_update, top_down = TRUE, dry_run = dry_run)
}

dm_upsert <- function(target_dm, dm, ..., dry_run = FALSE) {
  check_dots_empty()

  dm_persist(target_dm, dm, operation = tbl_upsert, top_down = TRUE, dry_run = dry_run)
}

dm_delete <- function(target_dm, dm, ..., dry_run = FALSE) {
  check_dots_empty()

  dm_persist(target_dm, dm, operation = tbl_delete, top_down = FALSE, dry_run = dry_run)
}

dm_truncate <- function(target_dm, dm, ..., dry_run = FALSE) {
  check_dots_empty()

  dm_persist(target_dm, dm, operation = tbl_truncate, top_down = FALSE, dry_run = dry_run)
}

dm_persist <- function(target_dm, dm, operation, top_down, dry_run = FALSE) {
  dm_check_persist(target_dm, dm)

  dm_run_persist(target_dm, dm, operation, top_down, dry_run)
}

tbl_insert <- function(target, source, ..., dry_run = FALSE) {
  UseMethod("tbl_insert", target)
}

tbl_insert.data.frame <- function(target, source, ..., dry_run = FALSE) {
  rbind(target, source)
}

tbl_insert.tbl_df <- function(target, source, ..., dry_run = FALSE) {
  bind_rows(target, source)
}

tbl_insert.tbl_dbi <- function(target, source, ..., dry_run = FALSE) {
  # Also in dry-run mode, for early notification of problems
  # Already quoted!?!
  name <- target_table_name(target, dry_run)

  if (dry_run) {
    union_all(target, source)
  } else {
    sql <- paste0(
      "INSERT INTO ", name, "\n",
      sql_render(source)
    )
    dbExecute(target$con, sql)
    invisible(NULL)
  }
}

dm_check_persist <- function(target_dm, dm) {
  check_not_zoomed(target_dm)
  check_not_zoomed(dm)

  check_same_src(target_dm, dm)
  walk2(dm_get_tables(target_dm), dm_get_tables(dm), check_columns_superset)
  check_keys_compatible(target_dm, dm)
}

dm_run_persist <- function(target_dm, dm, operation, top_down, dry_run) {
  # topologically sort tables
  # run operation(target_tbl, source_tbl, dry_run = dry_run) for each table
  # operation() returns NULL if no table is needed, otherwise a tbl
  # new_tables is list of non-NULL operation() values

  target_dm %>%
    dm_patch_tbl(!!!new_tables)
}

dm_patch_tbl <- function(dm, ...) {
  check_not_zoomed(dm)

  new_tables <- list2(...)

  # FIXME: Better error message for unknown tables

  def <- dm_get_def(dm)
  idx <- match(names(new_tables), def$table)
  def[idx, "data"] <- unname(new_tables)
  new_dm3(def)
}
```
