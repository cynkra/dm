% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/filter-dm.R
\name{cdm_filter}
\alias{cdm_filter}
\alias{cdm_apply_filters}
\title{Filtering a \code{\link{dm}} object}
\usage{
cdm_filter(dm, table, ...)

cdm_apply_filters(dm)
}
\arguments{
\item{dm}{A \code{dm} object.}

\item{table}{A table in the \code{dm}}

\item{...}{Logical predicates defined in terms of the variables in \code{.data}, passed on to \code{\link[dplyr:filter]{dplyr::filter()}}.
Multiple conditions are combined with \code{&} or \code{,}. Only rows where the condition evaluates
to TRUE are kept.

The arguments in ... are automatically quoted and evaluated in the context of
the data frame. They support unquoting and splicing. See \code{vignette("programming", package = "dplyr")}
for an introduction to these concepts.}
}
\description{
Filtering one table of a \code{\link{dm}} object may affect all tables connected to this table
via one or more steps of foreign key relations. Firstly, one or more filter conditions for
one or more tables can be defined using \code{cdm_filter()}, with a syntax similar to \code{dplyr::filter()}.
These conditions will be stored in the \code{\link{dm}} and not immediately executed. With \code{cdm_apply_filters()}
all tables will be updated according to the filter conditions and the foreign key relations.
}
\details{
\code{cdm_filter()} allows you to set one or more filter conditions for one table
of a \code{\link{dm}} object. These conditions will be stored in the \code{\link{dm}} for when they are needed.
The conditions are only evaluated in one of the following scenarios:
\enumerate{
\item Calling \code{cdm_apply_filters()} or \code{compute()} (method for \code{dm} objects) on a \code{dm}: each filtered table potentially
reduces the rows of all other tables connected to it by foreign key relations (cascading effect), only leaving the rows
with the corresponding key values. Isolated (in terms of foreign key constraints) and unfiltered tables are left untouched.
This results in a new \code{dm} class object.
\item Calling one of \code{tbl()}, \code{[[.dm()}, \code{$.dm()}: the remaining rows of the requested table are calculated based on the
filter conditions and the foreign key conditions (similar to 1. but only for one table)
}

It should be mentioned, that if an UNFILTERED table had a potential effect on other tables -- since it lacks key
values from connected tables --, these other tables are in general NOT affected by them when applying the filters.
If you want to enforce the effect of the reduction of rows to those rows, that have a reference value in a specific table,
you can set a filter condition like \code{1 == 1} in this table. The example with the \code{1 == 1} filter condition on this
help page illustrates this: when the \code{TRUE} (\code{1 == 1}) filter is set for table \code{flights}, it affects table \code{airports}.
In general all other tables of a relational data model could be affected by such a filter.

Several functions of the {dm} package will throw an error if unevaluated filter conditions exist when they are called.
}
\examples{
library(dplyr)

dm_nyc_filtered <-
  cdm_nycflights13() \%>\%
  cdm_filter(airports, name == "John F Kennedy Intl")

tbl(dm_nyc_filtered, "flights")
dm_nyc_filtered[["planes"]]
dm_nyc_filtered$airlines

cdm_nycflights13() \%>\%
  cdm_filter(airports, name == "John F Kennedy Intl") \%>\%
  cdm_apply_filters()

# If you want to only keep those rows in the parent tables
# whose primary key values appear as foreign key values in
# `flights`, you can set a `TRUE` filter in `flights`:
cdm_nycflights13() \%>\%
  cdm_filter(flights, 1 == 1) \%>\%
  cdm_apply_filters() \%>\%
  cdm_nrow()
# note, that in this example the only affected table is
# `airports` (since the departure airports in `flights` are
# only the 3 NYC ones).

cdm_nycflights13() \%>\%
  cdm_filter(flights, month == 3) \%>\%
  cdm_apply_filters()

library(dplyr)
cdm_nycflights13() \%>\%
  cdm_filter(planes, engine \%in\% c("Reciprocating", "4 Cycle")) \%>\%
  compute()
}
